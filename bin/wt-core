#!/usr/bin/env bash
# wt-core - Git Worktree Helper (core logic)
# https://github.com/kaloyanvi/wt
#
# This script outputs directives that shell wrappers interpret:
#   __WT_CD__:/path        - wrapper should cd to this path
#   __WT_CURSOR__:/path    - wrapper should open Cursor at this path
#   __WT_EXIT__:N          - wrapper should return exit code N
#
# All other output is displayed to the user.

set -e

WT_VERSION="1.0.0"

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

die() {
    echo "Error: $1" >&2
    echo "__WT_EXIT__:1"
    exit 0  # Exit 0 so wrapper can handle the directive
}

emit_cd() {
    echo "__WT_CD__:$1"
}

emit_cursor() {
    echo "__WT_CURSOR__:$1"
}

emit_exit() {
    echo "__WT_EXIT__:$1"
}

# Get the main repo path (works from any worktree).
get_main_repo() {
    local git_common_dir
    git_common_dir="$(git rev-parse --git-common-dir 2>/dev/null)" || return 1
    dirname "$git_common_dir"
}

# Interactive list picker with arrow key navigation.
# Usage: select_from_list "item1" "item2" "item3"
# Returns: selected item on stdout, or empty string if cancelled
select_from_list() {
    local items=("$@")
    local count=${#items[@]}
    local selected=0

    # Hide cursor (ANSI escape code).
    echo -en "\033[?25l" >&2

    # Restore cursor on exit.
    cleanup() {
        echo -en "\033[?25h" >&2
    }
    trap cleanup EXIT

    # Draw the list.
    draw_list() {
        local i
        for i in "${!items[@]}"; do
            if [[ $i -eq $selected ]]; then
                echo -e "\033[36m> ${items[$i]}\033[0m\033[K" >&2
            else
                echo -e "  ${items[$i]}\033[K" >&2
            fi
        done
    }

    # Initial draw.
    draw_list

    # Read input.
    while true; do
        local key
        IFS= read -rsn1 key </dev/tty

        case "$key" in
            $'\x1b')  # Escape sequence (arrow keys)
                read -rsn2 key </dev/tty
                case "$key" in
                    '[A')  # Up arrow
                        if ((selected > 0)); then
                            ((selected--))
                            echo -en "\033[${count}A" >&2
                            draw_list
                        fi
                        ;;
                    '[B')  # Down arrow
                        if ((selected < count - 1)); then
                            ((selected++))
                            echo -en "\033[${count}A" >&2
                            draw_list
                        fi
                        ;;
                esac
                ;;
            '')  # Enter key
                cleanup
                trap - EXIT
                echo "${items[$selected]}"
                return 0
                ;;
            'q')  # Quit
                cleanup
                trap - EXIT
                return 1
                ;;
        esac
    done
}

# -----------------------------------------------------------------------------
# Commands
# -----------------------------------------------------------------------------

cmd_create() {
    local feature_name=""
    local open_cursor=false

    # Parse arguments.
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c)
                open_cursor=true
                shift
                ;;
            -*)
                die "Unknown flag: $1"
                ;;
            *)
                feature_name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$feature_name" ]]; then
        echo "Usage: wt create <feature-name> [-c]"
        echo "  -c  Open the new worktree in Cursor"
        emit_exit 1
        return
    fi

    # Ensure we're in a git repo.
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        die "not inside a Git repository."
    fi

    # Get the main repo path.
    local main_repo
    main_repo="$(get_main_repo)" || die "could not determine main repository."

    local project_name
    project_name="$(basename "$main_repo")"

    local parent_dir
    parent_dir="$(dirname "$main_repo")"

    # Worktrees live in a sibling directory: <project>-worktrees/
    local worktrees_dir="${parent_dir}/${project_name}-worktrees"
    mkdir -p "$worktrees_dir"

    local new_worktree_path="${worktrees_dir}/${feature_name}"

    if [[ -e "$new_worktree_path" ]]; then
        die "destination already exists: $new_worktree_path"
    fi

    # Create worktree from the main repo.
    echo "Creating worktree at ${new_worktree_path}..."
    if ! git -C "$main_repo" worktree add -b "$feature_name" "$new_worktree_path"; then
        die "failed to create worktree."
    fi

    echo "Created branch '$feature_name' and worktree at:"
    echo "  $new_worktree_path"

    # Emit directives.
    if [[ "$open_cursor" == true ]]; then
        emit_cursor "$new_worktree_path"
    fi
    emit_cd "$new_worktree_path"
    emit_exit 0
}

cmd_co() {
    local open_cursor=false

    # Parse arguments.
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c)
                open_cursor=true
                shift
                ;;
            -*)
                die "Unknown flag: $1"
                ;;
            *)
                shift
                ;;
        esac
    done

    # Ensure we're in a git repo.
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        die "not inside a Git repository."
    fi

    # Get the main worktree path to exclude it from the list.
    local main_worktree
    main_worktree="$(get_main_repo)" || die "could not determine main repository."

    # Gather all worktree paths.
    local worktree_paths=()
    while IFS= read -r line; do
        if [[ "$line" == worktree\ * ]]; then
            local wt_path="${line#worktree }"
            # Exclude the main worktree.
            if [[ "$wt_path" != "$main_worktree" ]]; then
                worktree_paths+=("$wt_path")
            fi
        fi
    done < <(git worktree list --porcelain)

    if [[ ${#worktree_paths[@]} -eq 0 ]]; then
        die "no worktrees found (only main repo exists)."
    fi

    # Build parallel arrays of names and paths.
    local worktree_names=()
    local i
    for i in "${!worktree_paths[@]}"; do
        worktree_names+=("$(basename "${worktree_paths[$i]}")")
    done

    # Interactive selection.
    local selected_name
    selected_name="$(select_from_list "${worktree_names[@]}")"

    if [[ -z "$selected_name" ]]; then
        echo "Cancelled." >&2
        emit_exit 0
        return
    fi

    # Find the corresponding full path.
    local target_path=""
    for i in "${!worktree_names[@]}"; do
        if [[ "${worktree_names[$i]}" == "$selected_name" ]]; then
            target_path="${worktree_paths[$i]}"
            break
        fi
    done

    # Emit directives.
    if [[ "$open_cursor" == true ]]; then
        emit_cursor "$target_path"
    fi
    emit_cd "$target_path"
    emit_exit 0
}

cmd_update() {
    local wt_dir="${WT_INSTALL_DIR:-}"

    if [[ -z "$wt_dir" || ! -d "$wt_dir" ]]; then
        die "cannot determine wt installation directory. Is WT_INSTALL_DIR set?"
    fi

    if [[ ! -d "${wt_dir}/.git" ]]; then
        echo "Error: wt installation is not a git repository."
        echo "Re-install with: curl -fsSL https://raw.githubusercontent.com/kaloyanvidelov/wt/main/install.sh | bash"
        emit_exit 1
        return
    fi

    echo "Updating wt from GitHub..."

    if ! git -C "$wt_dir" fetch --quiet origin main; then
        die "failed to fetch from origin."
    fi

    local local_hash remote_hash
    local_hash="$(git -C "$wt_dir" rev-parse HEAD)"
    remote_hash="$(git -C "$wt_dir" rev-parse origin/main)"

    if [[ "$local_hash" == "$remote_hash" ]]; then
        echo "Already up to date."
        emit_exit 0
        return
    fi

    if ! git -C "$wt_dir" pull --ff-only origin main; then
        echo "Error: failed to pull updates. You may have local changes."
        echo "Run: cd ${wt_dir} && git status"
        emit_exit 1
        return
    fi

    echo ""
    echo "Updated successfully! Restart your shell or source your shell config."
    emit_exit 0
}

cmd_uninstall() {
    local wt_dir="${WT_INSTALL_DIR:-}"
    local shell_config=""

    if [[ -z "$wt_dir" || ! -d "$wt_dir" ]]; then
        die "cannot determine wt installation directory. Is WT_INSTALL_DIR set?"
    fi

    # Detect shell config file.
    if [[ -n "${ZSH_VERSION:-}" ]] || [[ "$SHELL" == *zsh* ]]; then
        shell_config="${HOME}/.zshrc"
    elif [[ -n "${BASH_VERSION:-}" ]] || [[ "$SHELL" == *bash* ]]; then
        shell_config="${HOME}/.bashrc"
    fi

    # Confirm before proceeding.
    echo "This will remove wt from your system:"
    echo "  - Delete ${wt_dir}"
    if [[ -n "$shell_config" ]]; then
        echo "  - Remove wt from ${shell_config}"
    fi
    echo ""
    echo -n "Are you sure? [y/N] "
    local confirm
    read -r confirm </dev/tty

    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Cancelled."
        emit_exit 0
        return
    fi

    echo ""
    echo "Uninstalling wt..."

    # Remove source lines from shell config.
    if [[ -n "$shell_config" && -f "$shell_config" ]]; then
        cp "$shell_config" "${shell_config}.bak"
        grep -v 'wt/shell/wt\.' "$shell_config" | grep -v '# wt - Git Worktree Helper' > "${shell_config}.tmp" || true
        mv "${shell_config}.tmp" "$shell_config"
        echo "Removed wt from ${shell_config} (backup: ${shell_config}.bak)"
    fi

    # Remove the installation directory.
    rm -rf "$wt_dir"
    echo "Removed ${wt_dir}"

    echo ""
    echo "Done! Restart your shell to complete uninstallation."
    emit_exit 0
}

cmd_help() {
    echo "wt - Git Worktree Helper (v${WT_VERSION})"
    echo ""
    echo "Usage: wt <command>"
    echo ""
    echo "Commands:"
    echo "  create <feature-name> [-c]  Create a new worktree and branch"
    echo "  co [-c]                     Pick an existing worktree"
    echo "  update                      Update wt to the latest version"
    echo "  uninstall                   Remove wt from the system"
    echo ""
    echo "Flags:"
    echo "  -c  Open in Cursor"
    emit_exit 1
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        create)
            cmd_create "$@"
            ;;
        co)
            cmd_co "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        uninstall)
            cmd_uninstall "$@"
            ;;
        --version|-v)
            echo "wt version ${WT_VERSION}"
            emit_exit 0
            ;;
        *)
            cmd_help
            ;;
    esac
}

main "$@"
