#!/usr/bin/env bash
# wt-core - Git Worktree Helper (core logic)
# https://github.com/kaloyanvi/wt
#
# This script outputs directives that shell wrappers interpret:
#   __WT_CD__:/path        - wrapper should cd to this path
#   __WT_CURSOR__:/path    - wrapper should open Cursor at this path
#   __WT_EXIT__:N          - wrapper should return exit code N
#
# All other output is displayed to the user.

set -e

WT_VERSION="1.0.0"

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

die() {
    echo "Error: $1" >&2
    echo "__WT_EXIT__:1"
    exit 0  # Exit 0 so wrapper can handle the directive
}

emit_cd() {
    echo "__WT_CD__:$1"
}

emit_cursor() {
    echo "__WT_CURSOR__:$1"
}

emit_exit() {
    echo "__WT_EXIT__:$1"
}

# Get the main repo path (works from any worktree).
get_main_repo() {
    local git_common_dir
    git_common_dir="$(git rev-parse --git-common-dir 2>/dev/null)" || return 1
    dirname "$git_common_dir"
}

# -----------------------------------------------------------------------------
# Commands
# -----------------------------------------------------------------------------

cmd_create() {
    local feature_name=""
    local open_cursor=false

    # Parse arguments.
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c)
                open_cursor=true
                shift
                ;;
            -*)
                die "Unknown flag: $1"
                ;;
            *)
                feature_name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$feature_name" ]]; then
        echo "Usage: wt create <feature-name> [-c]"
        echo "  -c  Open the new worktree in Cursor"
        emit_exit 1
        return
    fi

    # Ensure we're in a git repo.
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        die "not inside a Git repository."
    fi

    # Get the main repo path.
    local main_repo
    main_repo="$(get_main_repo)" || die "could not determine main repository."

    local project_name
    project_name="$(basename "$main_repo")"

    local parent_dir
    parent_dir="$(dirname "$main_repo")"

    # Worktrees live in a sibling directory: <project>-worktrees/
    local worktrees_dir="${parent_dir}/${project_name}-worktrees"
    mkdir -p "$worktrees_dir"

    local new_worktree_path="${worktrees_dir}/${feature_name}"

    if [[ -e "$new_worktree_path" ]]; then
        die "destination already exists: $new_worktree_path"
    fi

    # Create worktree from the main repo.
    echo "Creating worktree at ${new_worktree_path}..."
    if ! git -C "$main_repo" worktree add -b "$feature_name" "$new_worktree_path"; then
        die "failed to create worktree."
    fi

    echo "Created branch '$feature_name' and worktree at:"
    echo "  $new_worktree_path"

    # Emit directives.
    if [[ "$open_cursor" == true ]]; then
        emit_cursor "$new_worktree_path"
    fi
    emit_cd "$new_worktree_path"
    emit_exit 0
}

cmd_co() {
    # Ensure we're in a git repo.
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        die "not inside a Git repository."
    fi

    # Get the main worktree path to exclude it from the list.
    local main_worktree
    main_worktree="$(get_main_repo)" || die "could not determine main repository."

    # Gather all worktree paths.
    local worktree_paths=()
    while IFS= read -r line; do
        if [[ "$line" == worktree\ * ]]; then
            local wt_path="${line#worktree }"
            # Exclude the main worktree.
            if [[ "$wt_path" != "$main_worktree" ]]; then
                worktree_paths+=("$wt_path")
            fi
        fi
    done < <(git worktree list --porcelain)

    if [[ ${#worktree_paths[@]} -eq 0 ]]; then
        die "no worktrees found (only main repo exists)."
    fi

    # Display selection menu.
    echo "Select a worktree:"
    local i
    for i in "${!worktree_paths[@]}"; do
        echo "  $((i + 1))) ${worktree_paths[$i]}"
    done

    echo -n "Enter number (or press Enter to cancel): "
    local choice
    read -r choice </dev/tty

    if [[ -z "$choice" ]]; then
        echo "Cancelled."
        emit_exit 0
        return
    fi

    if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
        die "invalid selection."
    fi

    if (( choice < 1 || choice > ${#worktree_paths[@]} )); then
        die "selection out of range."
    fi

    local target_path="${worktree_paths[$((choice - 1))]}"

    # Emit directives.
    emit_cursor "$target_path"
    emit_cd "$target_path"
    emit_exit 0
}

cmd_update() {
    local wt_dir="${WT_INSTALL_DIR:-}"

    if [[ -z "$wt_dir" || ! -d "$wt_dir" ]]; then
        die "cannot determine wt installation directory. Is WT_INSTALL_DIR set?"
    fi

    if [[ ! -d "${wt_dir}/.git" ]]; then
        echo "Error: wt installation is not a git repository."
        echo "Re-install with: curl -fsSL https://raw.githubusercontent.com/kaloyanvidelov/wt/main/install.sh | bash"
        emit_exit 1
        return
    fi

    echo "Updating wt from GitHub..."

    if ! git -C "$wt_dir" fetch --quiet origin main; then
        die "failed to fetch from origin."
    fi

    local local_hash remote_hash
    local_hash="$(git -C "$wt_dir" rev-parse HEAD)"
    remote_hash="$(git -C "$wt_dir" rev-parse origin/main)"

    if [[ "$local_hash" == "$remote_hash" ]]; then
        echo "Already up to date."
        emit_exit 0
        return
    fi

    if ! git -C "$wt_dir" pull --ff-only origin main; then
        echo "Error: failed to pull updates. You may have local changes."
        echo "Run: cd ${wt_dir} && git status"
        emit_exit 1
        return
    fi

    echo ""
    echo "Updated successfully! Restart your shell or source your shell config."
    emit_exit 0
}

cmd_uninstall() {
    local wt_dir="${WT_INSTALL_DIR:-}"
    local shell_config=""

    if [[ -z "$wt_dir" || ! -d "$wt_dir" ]]; then
        die "cannot determine wt installation directory. Is WT_INSTALL_DIR set?"
    fi

    # Detect shell config file.
    if [[ -n "${ZSH_VERSION:-}" ]] || [[ "$SHELL" == *zsh* ]]; then
        shell_config="${HOME}/.zshrc"
    elif [[ -n "${BASH_VERSION:-}" ]] || [[ "$SHELL" == *bash* ]]; then
        shell_config="${HOME}/.bashrc"
    fi

    # Confirm before proceeding.
    echo "This will remove wt from your system:"
    echo "  - Delete ${wt_dir}"
    if [[ -n "$shell_config" ]]; then
        echo "  - Remove wt from ${shell_config}"
    fi
    echo ""
    echo -n "Are you sure? [y/N] "
    local confirm
    read -r confirm </dev/tty

    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Cancelled."
        emit_exit 0
        return
    fi

    echo ""
    echo "Uninstalling wt..."

    # Remove source lines from shell config.
    if [[ -n "$shell_config" && -f "$shell_config" ]]; then
        cp "$shell_config" "${shell_config}.bak"
        grep -v 'wt/shell/wt\.' "$shell_config" | grep -v '# wt - Git Worktree Helper' > "${shell_config}.tmp" || true
        mv "${shell_config}.tmp" "$shell_config"
        echo "Removed wt from ${shell_config} (backup: ${shell_config}.bak)"
    fi

    # Remove the installation directory.
    rm -rf "$wt_dir"
    echo "Removed ${wt_dir}"

    echo ""
    echo "Done! Restart your shell to complete uninstallation."
    emit_exit 0
}

cmd_help() {
    echo "wt - Git Worktree Helper (v${WT_VERSION})"
    echo ""
    echo "Usage: wt <command>"
    echo ""
    echo "Commands:"
    echo "  create <feature-name> [-c]  Create a new worktree and branch"
    echo "  co                          Pick an existing worktree"
    echo "  update                      Update wt to the latest version"
    echo "  uninstall                   Remove wt from the system"
    echo ""
    echo "Flags:"
    echo "  -c  Open in Cursor (for create)"
    emit_exit 1
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        create)
            cmd_create "$@"
            ;;
        co)
            cmd_co "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        uninstall)
            cmd_uninstall "$@"
            ;;
        --version|-v)
            echo "wt version ${WT_VERSION}"
            emit_exit 0
            ;;
        *)
            cmd_help
            ;;
    esac
}

main "$@"
